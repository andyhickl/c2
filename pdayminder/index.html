<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PDayMinder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- React + Babel from CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0c1116;
      --card-bg: #111827;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.15);
      --text: #e5e7eb;
      --muted: #6b7280;
      --border: #1f2933;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: stretch;
    }

    #root {
      width: 100%;
    }

    .app-shell {
      max-width: 480px;
      margin: 0 auto;
      padding: 12px 12px 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .app-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 2px 8px;
    }

    .app-title {
      font-size: 20px;
      font-weight: 600;
      letter-spacing: 0.04em;
    }

    .tagline {
      font-size: 11px;
      color: var(--muted);
    }

    .icon-btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.8);
      color: var(--text);
      padding: 4px 8px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      cursor: pointer;
    }

    .icon-btn:hover {
      background: rgba(15, 23, 42, 0.95);
    }

    .icon-btn.primary {
      border-color: var(--accent);
      background: var(--accent-soft);
    }

    .card {
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.14), transparent 60%),
                  radial-gradient(circle at bottom right, rgba(34, 197, 94, 0.12), transparent 55%),
                  var(--card-bg);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      padding: 10px 12px 12px;
      box-shadow:
        0 18px 45px rgba(15, 23, 42, 0.9),
        0 0 0 1px rgba(15, 23, 42, 0.7);
      backdrop-filter: blur(20px);
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .card-title {
      font-size: 14px;
      font-weight: 600;
    }

    .card-subtitle {
      font-size: 11px;
      color: var(--muted);
    }

    .day-nav {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
    }

    .day-nav-btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      padding: 4px 8px;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      flex-shrink: 0;
    }

    .day-nav-btn:hover {
      background: rgba(15, 23, 42, 1);
    }

    .day-nav-date {
      flex: 1;
      text-align: center;
      font-size: 13px;
      font-weight: 500;
    }

    .mini-calendar {
      margin-top: 4px;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 6px;
      background: rgba(15, 23, 42, 0.8);
      font-size: 11px;
    }

    .mini-cal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .mini-cal-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 2px;
    }

    .mini-cal-dayname {
      text-align: center;
      color: var(--muted);
      font-size: 10px;
      padding-bottom: 2px;
    }

    .mini-cal-cell {
      text-align: center;
      padding: 3px 0;
      border-radius: 999px;
      cursor: pointer;
      position: relative;
    }

    .mini-cal-cell.disabled {
      opacity: 0.25;
      cursor: default;
    }

    .mini-cal-cell.selected {
      background: var(--accent-soft);
      border: 1px solid var(--accent);
    }

    .mini-cal-cell.today {
      border: 1px dashed var(--accent);
    }

    .mini-cal-dot {
      width: 4px;
      height: 4px;
      border-radius: 999px;
      background: var(--accent);
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
    }

    .ring-container {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .ring-wrapper {
      width: 100%;
      max-width: 320px;
    }

    .ring-caption {
      font-size: 11px;
      color: var(--muted);
      text-align: center;
    }

    .controls-row {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-top: 6px;
      flex-wrap: wrap;
    }

    .pill-btn {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 6px 10px;
      font-size: 12px;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }

    .pill-btn.primary {
      border-color: var(--accent);
      background: var(--accent-soft);
    }

    .pill-btn:hover {
      background: rgba(15, 23, 42, 1);
    }

    .med-list {
      margin-top: 4px;
      font-size: 11px;
      color: var(--muted);
      text-align: center;
    }

    .med-list span {
      color: var(--text);
    }

    .settings-card {
      margin-top: 4px;
      font-size: 12px;
    }

    .settings-row {
      display: flex;
      gap: 8px;
      margin-bottom: 6px;
    }

    .settings-row label {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 11px;
      color: var(--muted);
    }

    .settings-input {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 4px 8px;
      font-size: 12px;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
    }

    .settings-help {
      font-size: 11px;
      color: var(--muted);
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.75);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 999;
      backdrop-filter: blur(4px);
    }

    .modal {
      background: var(--card-bg);
      border-radius: 16px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      padding: 12px;
      width: min(420px, calc(100% - 24px));
      box-shadow: 0 20px 45px rgba(0, 0, 0, 0.85);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .modal-title {
      font-size: 14px;
      font-weight: 600;
    }

    .modal-body {
      font-size: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    input[type="range"] {
      flex: 1;
    }

    .face-display {
      font-size: 24px;
      width: 34px;
      text-align: center;
    }

    .checkbox-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 12px;
    }

    .checkbox-inline {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 10px;
    }

    .btn-secondary, .btn-primary {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
    }

    .btn-secondary:hover {
      background: rgba(15, 23, 42, 1);
    }

    .btn-primary {
      border-color: var(--accent);
      background: var(--accent-soft);
    }

    .btn-primary:hover {
      background: rgba(56, 189, 248, 0.25);
    }

    .quick-times {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 2px;
    }

    .quick-time-pill {
      border-radius: 999px;
      border: 1px dashed var(--border);
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.9);
      color: var(--muted);
    }

    .quick-time-pill:hover {
      border-style: solid;
      color: var(--text);
    }

    .footer-note {
      margin-top: 8px;
      font-size: 10px;
      text-align: center;
      color: var(--muted);
    }

    /* QoL summary card (across all days) */
    .summary-card {
      margin-top: 4px;
    }

    .summary-chart {
      display: flex;
      align-items: flex-end;
      gap: 8px;
      height: 80px;
      margin-top: 4px;
      padding: 0 4px;
    }

    .summary-bar-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      gap: 2px;
      font-size: 10px;
      color: var(--muted);
    }

    .summary-bar {
      width: 100%;
      border-radius: 999px 999px 4px 4px;
      background: #4b5563;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .summary-bar-count {
      position: absolute;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 9px;
      color: #0b1120;
      font-weight: 600;
      text-shadow: 0 0 4px rgba(15, 23, 42, 0.6);
    }

    .summary-legend {
      margin-top: 4px;
      font-size: 11px;
      color: var(--muted);
      text-align: left;
    }

    .summary-legend strong {
      color: var(--text);
    }

    /* Data import/export */
    .data-card {
      margin-top: 4px;
      font-size: 12px;
    }

    .data-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }

    .data-actions button {
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 6px 10px;
      font-size: 12px;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text);
      cursor: pointer;
    }

    .data-actions button:hover {
      background: rgba(15, 23, 42, 1);
    }

    .data-note {
      margin-top: 4px;
      font-size: 11px;
      color: var(--muted);
    }

    @media (max-width: 400px) {
      .app-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
      }
      .settings-row {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef } = React;

    // ---------- Utilities ----------

    function toDateKey(date) {
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, "0");
      const d = String(date.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    function formatPrettyDate(date) {
      return date.toLocaleDateString(undefined, {
        weekday: "short",
        month: "short",
        day: "numeric",
        year: "numeric",
      });
    }

    function parseTimeToMinutes(timeStr) {
      const [h, m] = timeStr.split(":").map(Number);
      if (Number.isNaN(h) || Number.isNaN(m)) return 0;
      return h * 60 + m;
    }

    function minutesToTimeString(mins) {
      let m = mins % (24 * 60);
      if (m < 0) m += 24 * 60;
      const h = Math.floor(m / 60);
      const mm = m % 60;
      return String(h).padStart(2, "0") + ":" + String(mm).padStart(2, "0");
    }

    function isMinuteInSleep(minute, settings) {
      const start = parseTimeToMinutes(settings.sleepStart);
      const end = parseTimeToMinutes(settings.sleepEnd);
      if (start === end) return false;
      if (start < end) {
        return minute >= start && minute < end;
      } else {
        // crosses midnight
        return minute >= start || minute < end;
      }
    }

    // ---------- Colors & faces ----------

    function ratingColor(rating) {
      switch (rating) {
        case 1: return "#ef4444"; // red
        case 2: return "#f97316"; // orange
        case 3: return "#eab308"; // yellow
        case 4: return "#22c55e"; // green
        case 5: return "#0ea5e9"; // blue (distinct from 4)
        default: return "#374151"; // slate
      }
    }

    function faceForRating(r) {
      switch (r) {
        case 1: return "üò´";
        case 2: return "üòü";
        case 3: return "üòê";
        case 4: return "üôÇ";
        case 5: return "üòÑ";
        default: return "üôÇ";
      }
    }

    // ---------- Donut path helper ----------

    function describeDonutSegment(cx, cy, rInner, rOuter, startAngle, endAngle) {
      const x0 = cx + rOuter * Math.cos(startAngle);
      const y0 = cy + rOuter * Math.sin(startAngle);
      const x1 = cx + rOuter * Math.cos(endAngle);
      const y1 = cy + rOuter * Math.sin(endAngle);
      const x2 = cx + rInner * Math.cos(endAngle);
      const y2 = cy + rInner * Math.sin(endAngle);
      const x3 = cx + rInner * Math.cos(startAngle);
      const y3 = cy + rInner * Math.sin(startAngle);
      const largeArc = endAngle - startAngle <= Math.PI ? 0 : 1;

      return [
        "M", x0, y0,
        "A", rOuter, rOuter, 0, largeArc, 1, x1, y1,
        "L", x2, y2,
        "A", rInner, rInner, 0, largeArc, 0, x3, y3,
        "Z"
      ].join(" ");
    }

    // ---------- Default settings ----------

    const DEFAULT_SETTINGS = {
      sleepStart: "23:00",
      sleepEnd: "06:00",
      medTimes: ["08:00", "12:00", "16:00"], // updated defaults
    };

    // ---------- Local storage ----------

    function loadSettingsFromLocal() {
      try {
        const raw = localStorage.getItem("pdayminder-settings");
        if (!raw) return DEFAULT_SETTINGS;
        const parsed = JSON.parse(raw);
        return {
          sleepStart: parsed.sleepStart || DEFAULT_SETTINGS.sleepStart,
          sleepEnd: parsed.sleepEnd || DEFAULT_SETTINGS.sleepEnd,
          medTimes: Array.isArray(parsed.medTimes) && parsed.medTimes.length === 3
            ? parsed.medTimes
            : DEFAULT_SETTINGS.medTimes,
        };
      } catch {
        return DEFAULT_SETTINGS;
      }
    }

    function saveSettingsToLocal(settings) {
      localStorage.setItem("pdayminder-settings", JSON.stringify(settings));
    }

    function loadDaysFromLocal() {
      try {
        const raw = localStorage.getItem("pdayminder-days");
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed || {};
      } catch {
        return {};
      }
    }

    function saveDaysToLocal(days) {
      localStorage.setItem("pdayminder-days", JSON.stringify(days));
    }

    // ---------- CSV export/import ----------

    function exportDaysToCSV(days) {
      const header = "date,recordType,segmentIndex,segmentType,rating,medTime";
      const rows = [header];

      const sortedKeys = Object.keys(days).sort();
      for (const dateKey of sortedKeys) {
        const day = days[dateKey];
        if (!day) continue;

        // segments
        day.segments.forEach((seg, idx) => {
          const segmentType = seg.type || "empty";
          const rating = seg.rating != null ? seg.rating : "";
          rows.push([
            dateKey,
            "segment",
            idx,
            segmentType,
            rating,
            ""
          ].join(","));
        });

        // meds
        (day.meds || []).forEach((time) => {
          rows.push([
            dateKey,
            "med",
            "",
            "",
            "",
            time
          ].join(","));
        });
      }

      return rows.join("\n");
    }

    function importDaysFromCSV(text, settings) {
      const lines = text.trim().split(/\r?\n/);
      if (!lines.length) return {};
      const [, ...rows] = lines;

      const imported = {};

      for (const line of rows) {
        if (!line.trim()) continue;
        const cols = line.split(",").map(c => c.trim());
        const [dateKey, recordType, segmentIndexStr, segmentType, ratingStr, medTime] = cols;

        if (!dateKey || !recordType) continue;

        if (!imported[dateKey]) {
          imported[dateKey] = createEmptyDay(dateKey, settings);
        }
        const day = imported[dateKey];

        if (recordType === "segment") {
          const idx = parseInt(segmentIndexStr, 10);
          if (Number.isNaN(idx) || idx < 0 || idx >= day.segments.length) continue;
          const seg = { ...day.segments[idx] };
          seg.type = segmentType || "empty";
          seg.rating = ratingStr ? parseInt(ratingStr, 10) : 3;
          day.segments[idx] = seg;
        } else if (recordType === "med") {
          if (medTime) {
            day.meds.push(medTime);
          }
        }
      }

      // sort meds for each day
      for (const key in imported) {
        imported[key].meds.sort();
      }

      return imported;
    }

    // ---------- Day model helpers ----------

    // Segment types: "empty" | "rating" | "sleep" | "noData"
    function createEmptyDay(dateKey, settings) {
      const segments = Array.from({ length: 12 }, (_, idx) => ({
        type: "empty",
        rating: 3,
      }));
      // Mark sleep segments based on settings
      segments.forEach((seg, idx) => {
        const midMinute = idx * 120 + 60;
        if (isMinuteInSleep(midMinute, settings)) {
          seg.type = "sleep";
        }
      });
      return {
        dateKey,
        segments,
        meds: [], // times as "HH:MM"
      };
    }

    // ---------- Components ----------

    function MiniCalendar({ selectedDate, daysWithData, onSelect }) {
      const todayKey = toDateKey(new Date());
      const selectedKey = toDateKey(selectedDate);

      const firstOfMonth = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), 1);
      const firstDayIndex = firstOfMonth.getDay(); // Sunday=0
      const daysInMonth = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + 1, 0).getDate();

      const weeks = [];
      let currentDay = 1;
      let started = false;

      for (let week = 0; week < 6; week++) {
        const row = [];
        for (let dow = 0; dow < 7; dow++) {
          if (!started && dow === firstDayIndex) {
            started = true;
          }
          if (!started || currentDay > daysInMonth) {
            row.push(null);
          } else {
            row.push(currentDay);
            currentDay++;
          }
        }
        weeks.push(row);
      }

      const dayNames = ["S", "M", "T", "W", "T", "F", "S"];

      return (
        <div className="mini-calendar">
          <div className="mini-cal-header">
            <span>{selectedDate.toLocaleDateString(undefined, { month: "long", year: "numeric" })}</span>
            <span style={{ color: "var(--muted)", fontSize: "11px" }}>
              ‚Ä¢ days with a blue dot have entries
            </span>
          </div>
          <div className="mini-cal-grid">
            {dayNames.map((d) => (
              <div key={d} className="mini-cal-dayname">{d}</div>
            ))}
            {weeks.map((row, ri) =>
              row.map((d, di) => {
                if (!d) {
                  return <div key={`${ri}-${di}`} className="mini-cal-cell disabled"></div>;
                }
                const dateObj = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), d);
                const key = toDateKey(dateObj);
                const hasData = daysWithData.includes(key);
                const isSelected = key === selectedKey;
                const isToday = key === todayKey;
                const cls = [
                  "mini-cal-cell",
                  isSelected ? "selected" : "",
                  isToday ? "today" : "",
                ].join(" ");
                return (
                  <div
                    key={`${ri}-${di}`}
                    className={cls}
                    onClick={() => onSelect(dateObj)}
                  >
                    {d}
                    {hasData && <div className="mini-cal-dot"></div>}
                  </div>
                );
              })
            )}
          </div>
        </div>
      );
    }

    function DayRing({ day, onSegmentClick }) {
      const width = 260;
      const height = 260;
      const cx = width / 2;
      const cy = height / 2;
      const rOuter = 105;
      const rInner = 70;
      const segmentCount = 12;

      const segments = day.segments;

      function angleForTimeStr(timeStr) {
        const minutes = parseTimeToMinutes(timeStr);
        const fraction = minutes / (24 * 60);
        // midnight (0) at top -> -œÄ/2
        return fraction * Math.PI * 2 - Math.PI / 2;
      }

      return (
        <div className="ring-wrapper">
          <svg
            viewBox={`0 0 ${width} ${height}`}
            style={{ width: "100%", display: "block" }}
          >
            {/* Segments */}
            {segments.map((seg, idx) => {
              const startFrac = idx / segmentCount;
              const endFrac = (idx + 1) / segmentCount;
              const startAngle = startFrac * Math.PI * 2 - Math.PI / 2;
              const endAngle = endFrac * Math.PI * 2 - Math.PI / 2;

              let fill = "#1f2933";
              if (seg.type === "rating") {
                fill = ratingColor(seg.rating);
              } else if (seg.type === "sleep") {
                fill = "#4b5563";
              } else if (seg.type === "noData") {
                fill = "#374151";
              } else {
                fill = "#111827";
              }

              const path = describeDonutSegment(cx, cy, rInner, rOuter, startAngle, endAngle);

              const midAngle = (startAngle + endAngle) / 2;
              const iconRadius = (rInner + rOuter) / 2;
              const tx = cx + iconRadius * Math.cos(midAngle);
              const ty = cy + iconRadius * Math.sin(midAngle) + 4;

              let icon = "";
              if (seg.type === "sleep") icon = "üò¥";
              if (seg.type === "noData") icon = "?";

              const startHour = idx * 2;
              const endHour = startHour + 2;
              const label = `${String(startHour).padStart(2,"0")}:00‚Äì${String(endHour).padStart(2,"0")}:00`;

              return (
                <g key={idx} onClick={() => onSegmentClick(idx, label)}>
                  <path d={path} fill={fill} stroke="#020617" strokeWidth="1" />
                  {icon && (
                    <text
                      x={tx}
                      y={ty}
                      fontSize="12"
                      textAnchor="middle"
                      fill="#e5e7eb"
                    >
                      {icon}
                    </text>
                  )}
                </g>
              );
            })}

            {/* Time labels around the ring (start time of each 2h segment) */}
            {segments.map((_, idx) => {
              const startFrac = idx / segmentCount;
              const angle = startFrac * Math.PI * 2 - Math.PI / 2;
              const labelRadius = rOuter + 10;
              const x = cx + labelRadius * Math.cos(angle);
              const y = cy + labelRadius * Math.sin(angle) + 3;

              const startHour = idx * 2;
              const label = `${String(startHour).padStart(2, "0")}:00`;

              return (
                <text
                  key={`time-label-${idx}`}
                  x={x}
                  y={y}
                  fontSize="9"
                  textAnchor="middle"
                  fill="#9ca3af"
                >
                  {label}
                </text>
              );
            })}

            {/* Center label */}
            <circle cx={cx} cy={cy} r={rInner - 10} fill="#020617" />
            <text x={cx} y={cy - 4} textAnchor="middle" fontSize="11" fill="#9ca3af">
              QoL 1‚Äì5
            </text>
            <text x={cx} y={cy + 10} textAnchor="middle" fontSize="10" fill="#6b7280">
              tap a segment to rate QoL
            </text>

            {/* Med rays & labels */}
            {day.meds.map((t, i) => {
              const angle = angleForTimeStr(t);
              const innerR = rInner * 0.4;
              const outerR = rOuter * 1.05;
              const x1 = cx + innerR * Math.cos(angle);
              const y1 = cy + innerR * Math.sin(angle);
              const x2 = cx + outerR * Math.cos(angle);
              const y2 = cy + outerR * Math.sin(angle);

              // Slightly offset label angle to avoid overlapping time labels
              const labelAngle = angle + (6 * Math.PI / 180); // +6 degrees
              let labelRadius = rOuter + 22;
              const sinA = Math.sin(labelAngle);

              // If near bottom, pull label inward a bit so it doesn't collide with caption
              if (sinA > 0.75) {
                labelRadius = rOuter + 14;
              }

              const lx = cx + labelRadius * Math.cos(labelAngle);
              const ly = cy + labelRadius * Math.sin(labelAngle) + 3;

              return (
                <g key={`med-${i}-${t}`}>
                  <line
                    x1={x1}
                    y1={y1}
                    x2={x2}
                    y2={y2}
                    stroke="#38bdf8"
                    strokeWidth="2"
                    strokeLinecap="round"
                    opacity="0.9"
                  />
                  <text
                    x={lx}
                    y={ly}
                    fontSize="9"
                    textAnchor="middle"
                    fill="#38bdf8"
                  >
                    {t}
                  </text>
                </g>
              );
            })}
          </svg>
        </div>
      );
    }

    function SegmentModal({ open, segmentIndex, label, segment, onClose, onSave }) {
      const [rating, setRating] = useState(segment?.rating ?? 3);
      const [noData, setNoData] = useState(segment?.type === "noData");
      const [sleep, setSleep] = useState(segment?.type === "sleep");

      useEffect(() => {
        if (segment) {
          setRating(segment.rating ?? 3);
          setNoData(segment.type === "noData");
          setSleep(segment.type === "sleep");
        }
      }, [segmentIndex, segment]);

      if (!open || !segment) return null;

      const handleSave = () => {
        let newSeg;
        if (sleep) {
          newSeg = { type: "sleep", rating };
        } else if (noData) {
          newSeg = { type: "noData", rating };
        } else {
          newSeg = { type: "rating", rating };
        }
        onSave(segmentIndex, newSeg);
      };

      const disableSlider = noData || sleep;

      return (
        <div className="modal-backdrop" onClick={onClose}>
          <div className="modal" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <div>
                <div className="modal-title">Rate QoL for this 2-hour block</div>
                <div style={{ fontSize: "11px", color: "var(--muted)" }}>{label}</div>
              </div>
            </div>
            <div className="modal-body">
              <div style={{ fontSize: "11px", color: "var(--muted)" }}>
                Use the slider for your overall Quality of Life in this window, or mark it as sleep / no data.
              </div>
              <div className="slider-row">
                <span style={{ fontSize: "16px" }}>‚òπÔ∏è</span>
                <input
                  type="range"
                  min="1"
                  max="5"
                  step="1"
                  value={rating}
                  disabled={disableSlider}
                  onChange={(e) => setRating(parseInt(e.target.value, 10))}
                />
                <span style={{ fontSize: "16px" }}>üòä</span>
                <div className="face-display">
                  {sleep ? "üò¥" : noData ? "?" : faceForRating(rating)}
                </div>
              </div>
              <div className="checkbox-row">
                <label className="checkbox-inline">
                  <input
                    type="checkbox"
                    checked={noData}
                    onChange={(e) => {
                      const checked = e.target.checked;
                      setNoData(checked);
                      if (checked) setSleep(false);
                    }}
                  />
                  <span>No data for this block (show ‚Äú?‚Äù)</span>
                </label>
                <label className="checkbox-inline">
                  <input
                    type="checkbox"
                    checked={sleep}
                    onChange={(e) => {
                      const checked = e.target.checked;
                      setSleep(checked);
                      if (checked) setNoData(false);
                    }}
                  />
                  <span>Sleeping during this block (show üò¥)</span>
                </label>
              </div>
            </div>
            <div className="modal-footer">
              <button className="btn-secondary" onClick={onClose}>Cancel</button>
              <button className="btn-primary" onClick={handleSave}>Save</button>
            </div>
          </div>
        </div>
      );
    }

    function MedModal({ open, settings, onClose, onSave }) {
      const now = new Date();
      const defaultTime = minutesToTimeString(now.getHours() * 60 + now.getMinutes());
      const [time, setTime] = useState(defaultTime);

      useEffect(() => {
        if (open) {
          const n = new Date();
          setTime(minutesToTimeString(n.getHours() * 60 + n.getMinutes()));
        }
      }, [open]);

      if (!open) return null;

      const handleSave = () => {
        onSave(time);
      };

      return (
        <div className="modal-backdrop" onClick={onClose}>
          <div className="modal" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <div className="modal-title">Log medication</div>
            </div>
            <div className="modal-body">
              <div style={{ fontSize: "11px", color: "var(--muted)" }}>
                Choose the time you took your PD medication. It defaults to right now, but you can adjust.
              </div>
              <label style={{ display: "flex", flexDirection: "column", gap: "4px" }}>
                <span style={{ fontSize: "11px", color: "var(--muted)" }}>Time</span>
                <input
                  type="time"
                  className="settings-input"
                  value={time}
                  onChange={(e) => setTime(e.target.value)}
                />
              </label>
              <div style={{ marginTop: "4px", fontSize: "11px", color: "var(--muted)" }}>
                Quick fill (prescribed times):
              </div>
              <div className="quick-times">
                {settings.medTimes.map((t, idx) => (
                  <button
                    key={idx}
                    type="button"
                    className="quick-time-pill"
                    onClick={() => setTime(t)}
                  >
                    {t}
                  </button>
                ))}
              </div>
            </div>
            <div className="modal-footer">
              <button className="btn-secondary" onClick={onClose}>Cancel</button>
              <button className="btn-primary" onClick={handleSave}>Save</button>
            </div>
          </div>
        </div>
      );
    }

    function SettingsCard({ settings, onUpdate }) {
      const [local, setLocal] = useState(settings);

      useEffect(() => {
        setLocal(settings);
      }, [settings]);

      const handleChange = (field, value) => {
        const next = { ...local, [field]: value };
        setLocal(next);
        onUpdate(next);
      };

      const handleMedTimeChange = (index, value) => {
        const arr = [...local.medTimes];
        arr[index] = value;
        handleChange("medTimes", arr);
      };

      return (
        <div className="card settings-card">
          <div className="card-header">
            <div>
              <div className="card-title">Settings</div>
              <div className="card-subtitle">
                Defaults for sleep and medication times. New days use these to pre-fill the ring.
              </div>
            </div>
          </div>
          <div className="settings-row">
            <label>
              Sleep start
              <input
                type="time"
                className="settings-input"
                value={local.sleepStart}
                onChange={(e) => handleChange("sleepStart", e.target.value)}
              />
            </label>
            <label>
              Sleep end
              <input
                type="time"
                className="settings-input"
                value={local.sleepEnd}
                onChange={(e) => handleChange("sleepEnd", e.target.value)}
              />
            </label>
          </div>
          <div className="settings-row">
            <label>
              Med time 1
              <input
                type="time"
                className="settings-input"
                value={local.medTimes[0]}
                onChange={(e) => handleMedTimeChange(0, e.target.value)}
              />
            </label>
            <label>
              Med time 2
              <input
                type="time"
                className="settings-input"
                value={local.medTimes[1]}
                onChange={(e) => handleMedTimeChange(1, e.target.value)}
              />
            </label>
          </div>
          <div className="settings-row">
            <label>
              Med time 3
              <input
                type="time"
                className="settings-input"
                value={local.medTimes[2]}
                onChange={(e) => handleMedTimeChange(2, e.target.value)}
              />
            </label>
          </div>
          <div className="settings-help">
            Sleep can cross midnight (e.g., 23:00 ‚Üí 06:00). Any 2-hour segment whose midpoint falls in that window
            is marked as sleep by default on new days.
          </div>
        </div>
      );
    }

    function QoLSummaryCard({ days }) {
      const counts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
      let ratedSegments = 0;
      let totalSegments = 0;

      Object.values(days).forEach((day) => {
        day.segments.forEach((seg) => {
          totalSegments++;
          if (seg.type === "rating") {
            const r = seg.rating ?? 3;
            counts[r] = (counts[r] || 0) + 1;
            ratedSegments++;
          }
        });
      });

      const maxCount = Math.max(1, ...Object.values(counts));
      const goodOrBetter = (counts[4] || 0) + (counts[5] || 0);
      const avgQoL = ratedSegments
        ? (Object.entries(counts).reduce((sum, [r, c]) => sum + Number(r) * c, 0) / ratedSegments)
        : null;

      return (
        <div className="card summary-card">
          <div className="card-header">
            <div>
              <div className="card-title">QoL summary (all days)</div>
              <div className="card-subtitle">
                Total 2-hour segments across everything you&apos;ve logged, grouped by QoL rating.
              </div>
            </div>
          </div>
          <div className="summary-chart">
            {[1,2,3,4,5].map((r) => {
              const count = counts[r] || 0;
              const heightPct = (count / maxCount) * 100;
              const barStyle = {
                height: `${heightPct || 4}%`,
                background: `linear-gradient(to top, ${ratingColor(r)}, ${ratingColor(r)}dd)`,
                boxShadow: count
                  ? `0 0 6px ${ratingColor(r)}55`
                  : "none",
              };
              return (
                <div key={r} className="summary-bar-wrapper">
                  <div className="summary-bar" style={barStyle}>
                    {count > 0 && (
                      <div className="summary-bar-count">
                        {count}
                      </div>
                    )}
                  </div>
                  <div>
                    <span style={{ color: "#9ca3af" }}>{r}</span><br/>
                    <span>{faceForRating(r)}</span>
                  </div>
                </div>
              );
            })}
          </div>
          <div className="summary-legend">
            <div>
              Segments with QoL ‚â• 4:&nbsp;
              <strong>{goodOrBetter}</strong> / {totalSegments}
            </div>
            <div>
              Average QoL (rated segments only):&nbsp;
              <strong>{avgQoL ? avgQoL.toFixed(2) : "‚Äî"}</strong>
            </div>
            <div>
              Total days recorded:&nbsp;
              <strong>{Object.keys(days).length}</strong>
            </div>
          </div>
        </div>
      );
    }

    function DataCard({ days, setDays, settings }) {
      const fileInputRef = useRef(null);

      const handleExport = () => {
        const csv = exportDaysToCSV(days);
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        const todayKey = toDateKey(new Date());
        a.href = url;
        a.download = `pdayminder-${todayKey}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      const handleImportClick = () => {
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
          fileInputRef.current.click();
        }
      };

      const handleFileChange = (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const text = ev.target.result;
          const imported = importDaysFromCSV(String(text), settings);
          setDays((prev) => {
            const next = { ...prev };
            // Overwrite only the dates present in CSV, leave others intact
            Object.entries(imported).forEach(([key, day]) => {
              next[key] = day;
            });
            return next;
          });
        };
        reader.readAsText(file);
      };

      return (
        <div className="card data-card">
          <div className="card-header">
            <div>
              <div className="card-title">Data & backup</div>
              <div className="card-subtitle">
                Export/import QoL and medication data as CSV. Import overwrites matching dates only.
              </div>
            </div>
          </div>
          <div className="data-actions">
            <button type="button" onClick={handleExport}>‚¨áÔ∏è Export CSV</button>
            <button type="button" onClick={handleImportClick}>‚¨ÜÔ∏è Import CSV</button>
          </div>
          <div className="data-note">
            Importing will replace all segments and meds for dates present in the CSV, but leaves other dates untouched.
          </div>
          <input
            type="file"
            accept=".csv,text/csv"
            style={{ display: "none" }}
            ref={fileInputRef}
            onChange={handleFileChange}
          />
        </div>
      );
    }

    function App() {
      const [settings, setSettings] = useState(loadSettingsFromLocal);
      const [days, setDays] = useState(loadDaysFromLocal);
      const [selectedDate, setSelectedDate] = useState(() => new Date());
      const [showSettings, setShowSettings] = useState(false);
      const [segmentModalState, setSegmentModalState] = useState({
        open: false,
        index: null,
        label: "",
        segment: null,
      });
      const [medModalOpen, setMedModalOpen] = useState(false);

      const dateKey = toDateKey(selectedDate);

      // Ensure current day exists
      useEffect(() => {
        setDays((prev) => {
          if (prev[dateKey]) return prev;
          const newDay = createEmptyDay(dateKey, settings);
          const next = { ...prev, [dateKey]: newDay };
          saveDaysToLocal(next);
          return next;
        });
      }, [dateKey, settings]);

      // Persist to localStorage
      useEffect(() => {
        saveSettingsToLocal(settings);
      }, [settings]);

      useEffect(() => {
        saveDaysToLocal(days);
      }, [days]);

      // Optional: sync to server if backend exists (no-op if /api not available)
      useEffect(() => {
        async function loadFromServer() {
          try {
            const res = await fetch("/api/pdayminder/data");
            if (!res.ok) return;
            const payload = await res.json();
            if (payload.settings) {
              setSettings((prev) => ({ ...prev, ...payload.settings }));
            }
            if (payload.days) {
              setDays((prev) => ({ ...prev, ...payload.days }));
            }
          } catch (e) {
            // ignore if server not reachable
          }
        }
        loadFromServer();
      }, []);

      useEffect(() => {
        async function saveToServer() {
          try {
            await fetch("/api/pdayminder/data", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ settings, days }),
            });
          } catch (e) {
            // ignore if server not reachable
          }
        }
        saveToServer();
      }, [settings, days]);

      const day = days[dateKey] || createEmptyDay(dateKey, settings);
      const daysWithData = useMemo(() => Object.keys(days), [days]);

      const handleSegmentClick = (index, label) => {
        const seg = day.segments[index];
        setSegmentModalState({
          open: true,
          index,
          label,
          segment: seg,
        });
      };

      const handleSegmentSave = (index, newSeg) => {
        setDays((prev) => {
          const existing = prev[dateKey] || createEmptyDay(dateKey, settings);
          const dayCopy = { ...existing };
          const segs = dayCopy.segments.map((s, i) => (i === index ? { ...newSeg } : s));
          dayCopy.segments = segs;
          const next = { ...prev, [dateKey]: dayCopy };
          return next;
        });
        setSegmentModalState((s) => ({ ...s, open: false }));
      };

      const handleAddMed = (timeStr) => {
        setDays((prev) => {
          const existing = prev[dateKey] || createEmptyDay(dateKey, settings);
          const dayCopy = { ...existing };
          const meds = [...dayCopy.meds, timeStr].sort();
          dayCopy.meds = meds;
          const next = { ...prev, [dateKey]: dayCopy };
          return next;
        });
        setMedModalOpen(false);
      };

      const goToOffsetDay = (offset) => {
        const d = new Date(selectedDate);
        d.setDate(d.getDate() + offset);
        setSelectedDate(d);
      };

      const handleCalendarSelect = (d) => {
        setSelectedDate(d);
      };

      const medSummary = day.meds.length
        ? day.meds.join(", ")
        : "No meds logged yet";

      return (
        <div className="app-shell">
          <header className="app-header">
            <div>
              <div className="app-title">PDayMinder</div>
              <div className="tagline">Track meds and QoL, one ring per day.</div>
            </div>
            <button
              className={"icon-btn" + (showSettings ? " primary" : "")}
              onClick={() => setShowSettings((v) => !v)}
            >
              <span>‚öôÔ∏è</span>
              <span>{showSettings ? "Hide settings" : "Settings"}</span>
            </button>
          </header>

          {/* Day + calendar card */}
          <div className="card">
            <div className="card-header">
              <div>
                <div className="card-title">Day view</div>
                <div className="card-subtitle">One page per day. Arrows or calendar to change.</div>
              </div>
            </div>
            <div className="day-nav">
              <button className="day-nav-btn" type="button" onClick={() => goToOffsetDay(-1)}>
                <span>‚Üê</span> <span>Prev</span>
              </button>
              <div className="day-nav-date">{formatPrettyDate(selectedDate)}</div>
              <button className="day-nav-btn" type="button" onClick={() => goToOffsetDay(1)}>
                <span>Next</span> <span>‚Üí</span>
              </button>
            </div>
            <MiniCalendar
              selectedDate={selectedDate}
              daysWithData={daysWithData}
              onSelect={handleCalendarSelect}
            />
          </div>

          {/* Ring + controls */}
          <div className="card">
            <div className="card-header">
              <div>
                <div className="card-title">QoL ring</div>
                <div className="card-subtitle">
                  24 hours in 12 segments. QoL 1 (red) to 5 (blue), with meds as rays.
                </div>
              </div>
            </div>
            <div className="ring-container">
              <DayRing day={day} onSegmentClick={handleSegmentClick} />
              <div className="ring-caption">
                Red = tougher hours. Green/blue = better QoL. Gray with üò¥ = sleep, gray with ? = no data.
                Time labels mark the start of each 2-hour segment; med rays are labeled with their times.
              </div>
            </div>
            <div className="controls-row">
              <button
                type="button"
                className="pill-btn primary"
                onClick={() => setMedModalOpen(true)}
              >
                üíä Log medication
              </button>
            </div>
            <div className="med-list">
              <span>Today&apos;s doses:</span> {medSummary}
            </div>
          </div>

          {/* QoL summary across all days */}
          <QoLSummaryCard days={days} />

          {/* CSV data import/export */}
          <DataCard days={days} setDays={setDays} settings={settings} />

          {/* Settings */}
          {showSettings && (
            <SettingsCard
              settings={settings}
              onUpdate={(next) => setSettings(next)}
            />
          )}

          <div className="footer-note">
            Data is stored locally in this browser and optionally synced to <code>/api/pdayminder/data</code> if a backend is available.
            This is a prototype and not medical advice.
          </div>

          {/* Modals */}
          <SegmentModal
            open={segmentModalState.open}
            segmentIndex={segmentModalState.index}
            label={segmentModalState.label}
            segment={segmentModalState.segment}
            onClose={() => setSegmentModalState((s) => ({ ...s, open: false }))}
            onSave={handleSegmentSave}
          />
          <MedModal
            open={medModalOpen}
            settings={settings}
            onClose={() => setMedModalOpen(false)}
            onSave={handleAddMed}
          />
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>